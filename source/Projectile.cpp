//// Created by Elena Faillace on 08/07/2018.//#include "../include/Projectile.h"Textures::ID toTextureID(Projectile::Type type) {    switch(type) {        case Projectile::Type::energyBall:            return Textures::ShootingEnergy;        case Projectile::Type::redProjectile:            return Textures::redProjectile;    }}Projectile::Projectile(const TextureHolder& textures,  Type type): textures(textures), active(false), delayWalk(false),delayMoreWalk        (false), delayMoreMoreWalk(false), counterWalk(0), type(type) {    rect.setPosition(0, 0);    texture = textures.get(toTextureID(type));    sprite.setTexture(texture);    switch(type) {        case energyBall:            rect.setOrigin(30 / 2, 30 / 2);            sprite.setOrigin(56 / 2, 56 / 2);  //non credo necessario            rect.setSize(sf::Vector2f(30, 30));            sprite.setTextureRect((sf::IntRect(0, 0, 56, 56)));            attackDamage = 10;            break;        case redProjectile:            rect.setOrigin(18 / 2,  15/ 2);            sprite.setOrigin(18 / 2, 15 / 2);  //non credo necessario            rect.setSize(sf::Vector2f(18, 15));            sprite.setTextureRect((sf::IntRect(0, 0, 18, 15)));            attackDamage = 5;            break;    }}void Projectile::setPosition(const sf::Vector2f &position, Direction direction) {    active = true;    this->direction = direction;    rect.move(position);    sprite.setPosition(rect.getPosition());    initialPos = rect.getPosition();}const sf::Sprite &Projectile::getSprite() {    return Entity::getSprite();}void Projectile::update() {    switch(direction) {        case up:            rect.move(0,-movementSpeed);            break;        case down:            rect.move(0,movementSpeed);            break;        case left:            rect.move(-movementSpeed,0);            break;        case right:            rect.move(movementSpeed,0);            break;    }    if ( delayWalk ) {        if ( delayMoreWalk ) {            if(delayMoreMoreWalk)                if(type == energyBall) {                    counterWalk = (counterWalk + 1) % 4;                } else if(type == redProjectile)                    counterWalk = (counterWalk + 1) % 2;            delayMoreMoreWalk = !delayMoreMoreWalk;        }        delayMoreWalk = !delayMoreWalk;    }    delayWalk = !delayWalk;    if(type == energyBall) {        sprite.setTextureRect((sf::IntRect(counterWalk*58,0,56,56)));    } else if(type == redProjectile)        sprite.setTextureRect((sf::IntRect(counterWalk*18,0,18,15)));    if(abs(rect.getPosition().x-initialPos.x) > range || abs(rect.getPosition().y-initialPos.y) > range)        active = false;    //keeps rect and sprite together    sprite.setPosition(rect.getPosition());}