//// Created by Elena Faillace on 22/06/2018.//#include <iostream>#include "../include/Game.h"Game::Game(): mWindow(sf::VideoMode(640, 480), "BlackRose"), mPlayer(), mTexture(), timePerFrame(sf::seconds(1.f / 60.f)),              isMovingUp(false), isMovingDown(false), isMovingLeft(false), isMovingRight(false) {    if(!mTexture.loadFromFile("Media/Ship.png")) {        //Handle errors        std::cerr <<"non trova il file\n";    }    mPlayer.setTexture(mTexture);    mPlayer.setPosition(100.f,100.f);}void Game::run() {    sf::Clock clock;    sf::Time timeSinceLastUpdate = sf::Time::Zero;    while (mWindow.isOpen()) {        timeSinceLastUpdate += clock.restart();        //DOMANDA: se processEvents o update poi sono lenti non rischio di non stampare mai il risultato?        //If rendering is slow, it may happen that processEvents() and update() are called multiple times before one render()        while (timeSinceLastUpdate > timePerFrame) {            timeSinceLastUpdate -= timePerFrame;            processEvents();            update(timePerFrame);        }        render();    }}void Game::handlePlayerInput(sf::Keyboard::Key key, bool isPressed) {    if(key==sf::Keyboard::W) {        isMovingUp = isPressed;    }    else if(key==sf::Keyboard::S) {        isMovingDown = isPressed;    }    else if(key==sf::Keyboard::A) {        isMovingLeft = isPressed;    }    else if(key==sf::Keyboard::D) {        isMovingRight = isPressed;    }}void Game::processEvents() {    sf::Event event;    while (mWindow.pollEvent(event)) {        switch (event.type) {            case sf::Event::Closed:                mWindow.close();                break;            case sf::Event::KeyPressed:                handlePlayerInput(event.key.code, true);                break;            case sf::Event::KeyReleased:                handlePlayerInput(event.key.code, false);                break;            default:                break;        }    }}void Game::update(sf::Time deltaTime) {    sf::Vector2f movement(0.f,0.f);    if(isMovingUp)        movement.y -= playerSpeed;    if(isMovingDown)        movement.y += playerSpeed;    if(isMovingLeft)        movement.x -= playerSpeed;    if(isMovingRight)        movement.x += playerSpeed;    mPlayer.move(deltaTime.asSeconds() * movement);}void Game::render() {    mWindow.clear();    mWindow.draw(mPlayer);    mWindow.display();}