//// Created by Elena Faillace on 22/06/2018.//#include "../include/Game.h"const sf::Time Game::TimePerFrame = sf::seconds(1.f/60.f);Game::Game() : mWindow(sf::VideoMode(800, 800), "BlackRose", sf::Style::Close), mFont(), mStatisticsText(),               mStatisticsUpdateTime(), mStatisticsNumFrames(0), mWorld(mWindow) {    mFont.loadFromFile("Media/Sansation.ttf");    mStatisticsText.setFont(mFont);    mStatisticsText.setPosition(5.f, 5.f);    mStatisticsText.setCharacterSize(10);}void Game::run() {    sf::Clock clock;    sf::Time timeSinceLastUpdate = sf::Time::Zero;    while (mWindow.isOpen()) {        sf::Time elapsedTime = clock.restart();        timeSinceLastUpdate += elapsedTime;        //DOMANDA: se processEvents o update poi sono lenti non rischio di non stampare mai il risultato?        //If rendering is slow, it may happen that processEvents() and update() are called multiple times before one render()        while (timeSinceLastUpdate > TimePerFrame) {            timeSinceLastUpdate -= TimePerFrame;            processEvents();            update(elapsedTime);        }        render();    }}void Game::handlePlayerInput(sf::Keyboard::Key key, bool isPressed) {}void Game::processEvents() {    sf::Event event;    while (mWindow.pollEvent(event)) {        switch (event.type) {            case sf::Event::Closed:                mWindow.close();                break;            case sf::Event::KeyPressed:                handlePlayerInput(event.key.code, true);                break;            case sf::Event::KeyReleased:                handlePlayerInput(event.key.code, false);                break;            default:                break;        }    }}void Game::update(sf::Time deltaTime) {    mWorld.update(deltaTime);}void Game::render() {    mWindow.clear();    mWorld.draw();    mWindow.setView(mWindow.getDefaultView());    mWindow.draw(mStatisticsText);    mWindow.display();}void Game::updateStatistics(sf::Time elapsedTime) {    mStatisticsUpdateTime += elapsedTime;    mStatisticsNumFrames += 1;    if(mStatisticsUpdateTime >= sf::seconds(1.f)) {        mStatisticsText.setString("Frames / Second = " + std::to_string(mStatisticsNumFrames) + "\n" +                                  "Time / Update = " + std::to_string(mStatisticsUpdateTime.asMicroseconds() /                                                                mStatisticsNumFrames) + "us");        mStatisticsUpdateTime -= sf::seconds(1.f);        mStatisticsNumFrames = 0;    }}