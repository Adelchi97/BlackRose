//// Created by Elena Faillace on 26/06/2018.//#include "../include/SceneNode.h"SceneNode::SceneNode() : mParent(nullptr), mChildren() {}void SceneNode::attachChild(Ptr child) {    child->mParent = this;    //linear time and pass the ownership    mChildren.push_back(std::move(child));}SceneNode::Ptr SceneNode::detachChild(const SceneNode &node) {    //find_if return iterator to found element    auto found = std::find_if(mChildren.begin(),mChildren.end(),                              //ptr is a pointer to sceneNode                              [&](Ptr& ptr)-> bool { return ptr.get() == &node; });    //checks if found, end is an empty(?) iterator at the end o the array    assert(found != mChildren.end());    //found is an iterator poiting to Ptr    Ptr result = std::move(*found);    //safe delete of parent    result->mParent = nullptr;    mChildren.erase(found);    return result;}//draws the entire tree, where the argument are children//States are the same for every levelvoid SceneNode::draw(sf::RenderTarget &target, sf::RenderStates states) const {    //child modifies its transformation based on parent    states.transform *= getTransform(); //contains the absolute world transform            //drawCurren draws father and then every child calls draw, and drawCurrent on itself    drawCurrent(target, states);    //use iterators if it doesn't work    for ( const Ptr &child : mChildren )        child->draw(target, states);}void SceneNode::drawCurrent(sf::RenderTarget &target, sf::RenderStates states) const {    //do nothing by default}void SceneNode::update(sf::Time dt) {    updateCurrent(dt);    updateChildren(dt);}void SceneNode::updateCurrent(sf::Time dt) {    //do nothing by default}void SceneNode::updateChildren(sf::Time dt) {    for(Ptr& child : mChildren)        child->update(dt);}sf::Transform SceneNode::getWorldTransform() const {    sf::Transform transform = sf::Transform::Identity;        //non necessaria    for(const SceneNode* node = this; node!= nullptr; node = node->mParent)        transform = node->getTransform()*transform;    return transform;}sf::Vector2f SceneNode::getWorldPosition() const {    return getWorldTransform() * sf::Vector2f();    //???????????????????????}